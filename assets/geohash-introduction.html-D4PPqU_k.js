import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,b as s,o as n}from"./app-DImQijK3.js";const t="/assets/haversine-BkdhyefL.png",h="/assets/haversine-label-BqyTs9DB.png",o="/assets/geohash-binary-code-DwSwMBjw.jpg",p="/assets/geohash-binary-lng-D6tKyP2I.png",r="/assets/base32-dict-CYsEBtBF.png",l="/assets/geohash-precision-zORnBywz.png",d="/assets/geohash-grid-D80e02J1.png",g={};function c(k,e){return n(),a("div",null,e[0]||(e[0]=[s('<h1 id="地理空间邻近算法-geohash" tabindex="-1"><a class="header-anchor" href="#地理空间邻近算法-geohash"><span>地理空间邻近算法：GeoHash</span></a></h1><h2 id="问题背景" tabindex="-1"><a class="header-anchor" href="#问题背景"><span>问题背景</span></a></h2><p>假设要开发一款基于地理位置的交友软件，其中最核心的功能为用户匹配其邻近的用户。为了实现这个功能，可以把每个用户的经纬度记录下来，之后，可以使用半正矢公式计算两个用户经纬度之间的距离。</p><figure><img src="'+t+'" alt="haversine.png" tabindex="0" loading="lazy"><figcaption>haversine.png</figcaption></figure><figure><img src="'+h+'" alt="haversine-label.png" tabindex="0" loading="lazy"><figcaption>haversine-label.png</figcaption></figure><p>可以把用户经纬度数据都存到数据库里，然后用SQL查询附近的用户：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> user </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> latitude </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">between</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> LAT-D </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">and</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> LAT+D </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">and</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> longitude </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">between</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> LNG-D </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">and</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> LNG+D;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>LAT</code>是当前用户的纬度，<code>LNG</code>是当前用户的经度，<code>D</code>是要查在当前用户经纬度范围值。</p><p>这里用经纬度计算近似距离，在高纬度，这种计算的偏差比较大。如果在SQL里使用距离计算公式，则会导致索引失效。</p><h2 id="geohash" tabindex="-1"><a class="header-anchor" href="#geohash"><span>GeoHash</span></a></h2><p>GeoHash算法是一种地理位置编码算法，通过将地图切分成网格，将二维的地理位置经纬度转为一维的GeoHash编码。所以，GeoHash编码代表的是一个区域，而不是一个点。</p><h3 id="将经纬度分别编码为二进制串" tabindex="-1"><a class="header-anchor" href="#将经纬度分别编码为二进制串"><span>将经纬度分别编码为二进制串</span></a></h3><p>分别将经度、纬度编码为二进制字符串。纬度范围为<code>[-90, 90]</code>，将该区间从中间划开，如果当前纬度位于区间左边，则编码为<code>0</code>，在区间右边编码为<code>1</code>，在新的区间继续重复上述操作，直到精度符合要求。</p><figure><img src="'+o+'" alt="img.png" tabindex="0" loading="lazy"><figcaption>img.png</figcaption></figure><p>经度范围为<code>[-180, 180]</code>，进行类似的编码。</p><figure><img src="'+p+'" alt="img.png" tabindex="0" loading="lazy"><figcaption>img.png</figcaption></figure><h3 id="合并经度、纬度二进制串" tabindex="-1"><a class="header-anchor" href="#合并经度、纬度二进制串"><span>合并经度、纬度二进制串</span></a></h3><p>将经纬度二进制串交叉组合，经度放在偶数位（包括0），纬度放在奇数位。<br> 例如：</p><ul><li>经度：<code>11010101011101111110101111</code></li><li>纬度：<code>10101011000010010101010001</code></li><li>合并：<code>1110011001100111001010100110101110111001100110101011</code></li></ul><h3 id="二进制编码为base32编码" tabindex="-1"><a class="header-anchor" href="#二进制编码为base32编码"><span>二进制编码为Base32编码</span></a></h3><p>将二进制串，按每5位转为十进制数字，然后再编码成Base32编码。</p><figure><img src="'+r+'" alt="img.png" tabindex="0" loading="lazy"><figcaption>img.png</figcaption></figure><p>例如：<code>1011001101</code>，<code>10110=22=q</code>，<code>01101=13=e</code>，所以编码位<code>qe</code>。</p><h3 id="完整算法例子" tabindex="-1"><a class="header-anchor" href="#完整算法例子"><span>完整算法例子</span></a></h3><p>纬度、经度：（-20.12, 100.13）。编码长度为12。</p><ul><li>纬度二进制：<code>011000110110001010001000000101</code></li><li>经度二进制：<code>110001110011010000011100001101</code></li><li>合并二进制：<code>101101000010111100011110001001000100001011100000000010110011</code></li><li>12位编码：<code>qhrjw922w05m</code></li></ul><p>Java代码实现可参考：<a href="https://github.com/coldgust/GeoHash-Java" target="_blank" rel="noopener noreferrer">https://github.com/coldgust/GeoHash-Java</a></p><h2 id="geohash精度" tabindex="-1"><a class="header-anchor" href="#geohash精度"><span>GeoHash精度</span></a></h2><figure><img src="'+l+'" alt="img.png" tabindex="0" loading="lazy"><figcaption>img.png</figcaption></figure><h2 id="查找附近的人" tabindex="-1"><a class="header-anchor" href="#查找附近的人"><span>查找附近的人</span></a></h2><p>GeoHash编码如果前缀相同越多的地理位置越接近，但反之不成立。例如，在第一次二分时刚好位于边界的两个编码，第一位就不一样，但实际的地理位置很接近。为了避免这种情况，可以以当前格子为中心，找出和其相邻的8个格子。</p><figure><img src="'+d+'" alt="img.png" tabindex="0" loading="lazy"><figcaption>img.png</figcaption></figure><p>其中最小的经纬度单元格和二进制串的长度有关。<code>min_lat = (MAX_LAT - MIN_LAT) / (1 &lt;&lt; n)</code>。<code>MAX_LAT = 90</code>，<code>MIN_LAT = -90</code>，<code>n</code>为二进制字符串长度。经度的计算方式类似。</p><p>最后，找出这9个格子里的所有用户，再使用距离计算公式计算当前用户与这9个格子里所有用户的距离，找出符合条件的用户。</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料：</span></a></h2><ul><li><a href="http://geohash.co/" target="_blank" rel="noopener noreferrer">GeoHash在线编码</a></li><li><a href="https://luoming1224.github.io/2019/04/04/%5Bredis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5DGeoHash%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener noreferrer">[redis学习笔记]GeoHash算法详解及其实现</a></li></ul>',36)]))}const u=i(g,[["render",c]]),f=JSON.parse('{"path":"/posts/geohash-introduction.html","title":"地理空间邻近算法：GeoHash","lang":"zh-CN","frontmatter":{"category":["空间"],"tag":["算法"],"date":"2024-06-16T00:00:00.000Z","description":"地理空间邻近算法：GeoHash 问题背景 假设要开发一款基于地理位置的交友软件，其中最核心的功能为用户匹配其邻近的用户。为了实现这个功能，可以把每个用户的经纬度记录下来，之后，可以使用半正矢公式计算两个用户经纬度之间的距离。 haversine.pnghaversine.png haversine-label.pnghaversine-label.p...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"地理空间邻近算法：GeoHash\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-06-16T00:00:00.000Z\\",\\"dateModified\\":\\"2025-06-09T14:50:45.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"coldgust\\",\\"url\\":\\"https://github.com/coldgust\\",\\"email\\":\\"zhengxiaojian@apache.org\\"}]}"],["meta",{"property":"og:url","content":"https://coldgust.github.io/posts/geohash-introduction.html"}],["meta",{"property":"og:site_name","content":"coldgust"}],["meta",{"property":"og:title","content":"地理空间邻近算法：GeoHash"}],["meta",{"property":"og:description","content":"地理空间邻近算法：GeoHash 问题背景 假设要开发一款基于地理位置的交友软件，其中最核心的功能为用户匹配其邻近的用户。为了实现这个功能，可以把每个用户的经纬度记录下来，之后，可以使用半正矢公式计算两个用户经纬度之间的距离。 haversine.pnghaversine.png haversine-label.pnghaversine-label.p..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-09T14:50:45.000Z"}],["meta",{"property":"article:tag","content":"算法"}],["meta",{"property":"article:published_time","content":"2024-06-16T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-09T14:50:45.000Z"}]]},"git":{"createdTime":1718530933000,"updatedTime":1749480645000,"contributors":[{"name":"Xiaojian Zheng","username":"","email":"zhengxiaojian@apache.org","commits":3}]},"readingTime":{"minutes":5.65,"words":848},"filePathRelative":"posts/geohash-introduction.md","excerpt":"\\n<h2>问题背景</h2>\\n<p>假设要开发一款基于地理位置的交友软件，其中最核心的功能为用户匹配其邻近的用户。为了实现这个功能，可以把每个用户的经纬度记录下来，之后，可以使用半正矢公式计算两个用户经纬度之间的距离。</p>\\n<figure><figcaption>haversine.png</figcaption></figure>\\n<figure><figcaption>haversine-label.png</figcaption></figure>\\n<p>可以把用户经纬度数据都存到数据库里，然后用SQL查询附近的用户：</p>\\n<div class=\\"language-sql line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"sql\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code class=\\"language-sql\\"><span class=\\"line\\"><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">select</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\"> * </span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">from</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\"> user </span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">where</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\"> latitude </span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">between</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\"> LAT-D </span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">and</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\"> LAT+D </span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">and</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\"> longitude </span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">between</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\"> LNG-D </span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">and</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\"> LNG+D;</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{u as comp,f as data};
