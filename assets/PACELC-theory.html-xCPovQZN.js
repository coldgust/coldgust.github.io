import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,b as a,o as n}from"./app-DImQijK3.js";const i="/assets/redis-doc1-CnBdWxEs.png",s="/assets/redis-doc2-CKHJdmWe.png",r={};function c(p,t){return n(),o("div",null,t[0]||(t[0]=[a('<h1 id="pacelc理论" tabindex="-1"><a class="header-anchor" href="#pacelc理论"><span>PACELC理论</span></a></h1><p>如果有网络分区partition (P)，系统就必须在可用性availability和一致性consistency (A and C)之间取得平衡; 否则else (E) 当系统运行在无分区情况下,系统需要在 延迟latency (L) 和 consistency (C)之间取得平衡。</p><p>PACELC定理是CAP定理的扩展。</p><h2 id="mongodb" tabindex="-1"><a class="header-anchor" href="#mongodb"><span>MongoDB</span></a></h2><p>MongoDB（默认配置）下是PA/EC系统，mongo读写都在主节点上，它只需在主节点上写入成功就返回（不像raft需要多数复制成功），当主节点和备节点分区时，可能会丢失数据，所以说PA，在无分区的情况下，由于读写都在主节点，肯定能读到最新写入的数据，所以是EC。另外Mongo可以配置为写入大多数节点读主节点，这样就是PC/EC系统了。</p><h2 id="redis" tabindex="-1"><a class="header-anchor" href="#redis"><span>Redis</span></a></h2><p>在分析Redis Cluster的一致性模型之前，我们先来看看Redis Cluster数据分片策略，它并没有使用常见的一致性哈希算法，而是使用哈希槽（Hash Slot），总共有2^14个槽，把这些槽分配到主节点，使用CRC-16(key) % 2^14确定该key属于哪个节点。新增或删除节点，需要手动分配槽（一致性哈希算法按照顺时针重新分布节点，不需要手动调整）。</p><p>在默认配置下，redis cluster读写都在主节点上，使用gossip协议复制数据到副本，实现的是最终一致性。存在分区的情况下，主节点宕机，副本未复制到最新的数据，出现掉数据的情况。所以是PA。无分区情况下，读写都在主节点，一定能读到最新写入的数据，所以是EC。其次，redis cluster可以配置读写分离，在主节点写，在从节点读，这样就是EL。<br><img src="'+i+'" alt="redis-doc1.png" loading="lazy"></p><p>其次，redis cluster 提供了WAIT命令同步复制副本数据，但依然不能实现强一致性。大概原因是，redis cluster同步复制没有二阶段提交协议（2PC），也就是说，它是尽最大努力复制，如果有的副本节点复制失败，也不会撤销已经复制成功的节点。假设出现分区，主节点出现在少数区，集群检测到分区需要一定的时间窗口（这个可以配置多少），在这个时间窗口内主节点仍可接受客户端的写入，在多数区的某一个节点成功当选主节点，这样在这个时间窗口内写入原主节点的数据就丢失了。<br><img src="'+s+'" alt="redis-doc2.png" loading="lazy"></p>',9)]))}const C=e(r,[["render",c]]),m=JSON.parse('{"path":"/posts/PACELC-theory.html","title":"PACELC理论","lang":"zh-CN","frontmatter":{"category":["分布式"],"tag":["PACELC","CAP"],"date":"2024-04-24T00:00:00.000Z","star":true,"description":"PACELC理论 如果有网络分区partition (P)，系统就必须在可用性availability和一致性consistency (A and C)之间取得平衡; 否则else (E) 当系统运行在无分区情况下,系统需要在 延迟latency (L) 和 consistency (C)之间取得平衡。 PACELC定理是CAP定理的扩展。 Mongo...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"PACELC理论\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-04-24T00:00:00.000Z\\",\\"dateModified\\":\\"2024-04-23T16:15:12.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"coldgust\\",\\"url\\":\\"https://github.com/coldgust\\",\\"email\\":\\"zhengxiaojian@apache.org\\"}]}"],["meta",{"property":"og:url","content":"https://coldgust.github.io/posts/PACELC-theory.html"}],["meta",{"property":"og:site_name","content":"coldgust"}],["meta",{"property":"og:title","content":"PACELC理论"}],["meta",{"property":"og:description","content":"PACELC理论 如果有网络分区partition (P)，系统就必须在可用性availability和一致性consistency (A and C)之间取得平衡; 否则else (E) 当系统运行在无分区情况下,系统需要在 延迟latency (L) 和 consistency (C)之间取得平衡。 PACELC定理是CAP定理的扩展。 Mongo..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-23T16:15:12.000Z"}],["meta",{"property":"article:tag","content":"CAP"}],["meta",{"property":"article:tag","content":"PACELC"}],["meta",{"property":"article:published_time","content":"2024-04-24T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-23T16:15:12.000Z"}]]},"git":{"createdTime":1713888912000,"updatedTime":1713888912000,"contributors":[{"name":"Xiaojian Zheng","username":"","email":"zhengxiaojian@apache.org","commits":1}]},"readingTime":{"minutes":4.49,"words":673},"filePathRelative":"posts/PACELC-theory.md","excerpt":"\\n<p>如果有网络分区partition (P)，系统就必须在可用性availability和一致性consistency (A and C)之间取得平衡; 否则else (E) 当系统运行在无分区情况下,系统需要在 延迟latency (L) 和 consistency (C)之间取得平衡。</p>\\n<p>PACELC定理是CAP定理的扩展。</p>\\n<h2>MongoDB</h2>\\n<p>MongoDB（默认配置）下是PA/EC系统，mongo读写都在主节点上，它只需在主节点上写入成功就返回（不像raft需要多数复制成功），当主节点和备节点分区时，可能会丢失数据，所以说PA，在无分区的情况下，由于读写都在主节点，肯定能读到最新写入的数据，所以是EC。另外Mongo可以配置为写入大多数节点读主节点，这样就是PC/EC系统了。</p>","autoDesc":true}');export{C as comp,m as data};
