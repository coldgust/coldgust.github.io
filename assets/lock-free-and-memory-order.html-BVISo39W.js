import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,b as s,o as t}from"./app-DImQijK3.js";const r="/assets/acquire-release-BJUNfXOV.png",n={};function l(p,e){return t(),i("div",null,e[0]||(e[0]=[s('<h1 id="无锁编程与内存顺序" tabindex="-1"><a class="header-anchor" href="#无锁编程与内存顺序"><span>无锁编程与内存顺序</span></a></h1><p>无锁编程里最复杂，最难理解的莫过于是内存顺序。</p><h2 id="乱序" tabindex="-1"><a class="header-anchor" href="#乱序"><span>乱序</span></a></h2><p>程序不一定会按照源代码的顺序执行，这称之为乱序。乱序的必须遵循的原则是：在单线程执行下，乱序与不乱序执行的结果必须相同。所以，在单线程的环境里不需要注意乱序的问题，而到了多线程环境就需要考虑乱序。</p><p>乱序产生的原因有好几种：</p><ul><li>编译器优化，在编译阶段将源码交换。</li><li>程序执行期间，指令流水被CPU乱序执行。</li><li>inherent cache 的分层及刷新策略使得有时候某些写读操作的从效果上看，顺序被重排。</li></ul><h2 id="release和acquire语义" tabindex="-1"><a class="header-anchor" href="#release和acquire语义"><span>Release和Acquire语义</span></a></h2><p>release和acquire必须配合在一起使用，分开使用没有意义。release只能用于写操作，而acquire只能用于读操作。它们两结合在一起表达这样一个约定：<strong>如果一个线程A对一块内存 m 以 release 的方式进行修改，那么在线程 A 中，所有在该 release 操作之前进行的内存操作，都在另一个线程 B 对内存 m 以 acquire 的方式进行读取之后，变得可见。</strong></p><p>release和acquire是针对两个线程来说的，如果有C线程以非acquire读取内存m，则它的行为是不确定的。</p><p>这个描述还隐含这样的信息：release之前的内存操作不允许重排序到release之后，acquire之后的内存操作不允许重排序到acquire之前。</p><p>现代处理器通常还会支持一些RMW（read-modify-write）指令，对于这种指令，既要release也要acquire语义，C++11的<code>memory_order_acq_rel</code>结合了这两种语义，还提供了内存屏障功能。</p><figure><img src="'+r+'" alt="acquire and release" tabindex="0" loading="lazy"><figcaption>acquire and release</figcaption></figure><h2 id="顺序一致性-sequential-consistency" tabindex="-1"><a class="header-anchor" href="#顺序一致性-sequential-consistency"><span>顺序一致性（Sequential Consistency）</span></a></h2><p>顺序一致性是指所有的线程都观察到相同的内存操作顺序，相当于release + acquire之外，还对该操作加上了全剧顺序一致的要求。</p><p>例如：a、b初始值为0，</p><p>线程 A 执行：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">store</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, seq_cst);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>线程 B 执行：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">b</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">store</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">4</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, seq_cst);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在所有线程里，观察到的执行顺序是一样的。所以，a == 0 &amp;&amp; b == 4 和 a == 3 &amp;&amp; b == 0 不可能同时成立。</p><p>在Java里可通过标记变量为<code>volatile</code>实现顺序一致性。</p><h2 id="reference" tabindex="-1"><a class="header-anchor" href="#reference"><span>Reference</span></a></h2><ul><li><a href="https://www.cnblogs.com/catch/p/3803130.html" target="_blank" rel="noopener noreferrer">c++11 内存模型解读</a></li><li><a href="https://preshing.com/20120913/acquire-and-release-semantics/" target="_blank" rel="noopener noreferrer">Acquire and Release Semantics</a></li></ul>',23)]))}const h=a(n,[["render",l]]),d=JSON.parse('{"path":"/posts/lock-free-and-memory-order.html","title":"无锁编程与内存顺序","lang":"zh-CN","frontmatter":{"category":["并发编程","无锁编程"],"tag":["无锁并发"],"date":"2023-10-30T00:00:00.000Z","star":true,"description":"无锁编程与内存顺序 无锁编程里最复杂，最难理解的莫过于是内存顺序。 乱序 程序不一定会按照源代码的顺序执行，这称之为乱序。乱序的必须遵循的原则是：在单线程执行下，乱序与不乱序执行的结果必须相同。所以，在单线程的环境里不需要注意乱序的问题，而到了多线程环境就需要考虑乱序。 乱序产生的原因有好几种： 编译器优化，在编译阶段将源码交换。 程序执行期间，指令流...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"无锁编程与内存顺序\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-10-30T00:00:00.000Z\\",\\"dateModified\\":\\"2023-10-29T16:41:29.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"coldgust\\",\\"url\\":\\"https://github.com/coldgust\\",\\"email\\":\\"zhengxiaojian@apache.org\\"}]}"],["meta",{"property":"og:url","content":"https://coldgust.github.io/posts/lock-free-and-memory-order.html"}],["meta",{"property":"og:site_name","content":"coldgust"}],["meta",{"property":"og:title","content":"无锁编程与内存顺序"}],["meta",{"property":"og:description","content":"无锁编程与内存顺序 无锁编程里最复杂，最难理解的莫过于是内存顺序。 乱序 程序不一定会按照源代码的顺序执行，这称之为乱序。乱序的必须遵循的原则是：在单线程执行下，乱序与不乱序执行的结果必须相同。所以，在单线程的环境里不需要注意乱序的问题，而到了多线程环境就需要考虑乱序。 乱序产生的原因有好几种： 编译器优化，在编译阶段将源码交换。 程序执行期间，指令流..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-10-29T16:41:29.000Z"}],["meta",{"property":"article:tag","content":"无锁并发"}],["meta",{"property":"article:published_time","content":"2023-10-30T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-10-29T16:41:29.000Z"}]]},"git":{"createdTime":1698597689000,"updatedTime":1698597689000,"contributors":[{"name":"Xiaojian Zheng","username":"","email":"zhengxiaojian@apache.org","commits":1}]},"readingTime":{"minutes":4.33,"words":649},"filePathRelative":"posts/lock-free-and-memory-order.md","excerpt":"\\n<p>无锁编程里最复杂，最难理解的莫过于是内存顺序。</p>\\n<h2>乱序</h2>\\n<p>程序不一定会按照源代码的顺序执行，这称之为乱序。乱序的必须遵循的原则是：在单线程执行下，乱序与不乱序执行的结果必须相同。所以，在单线程的环境里不需要注意乱序的问题，而到了多线程环境就需要考虑乱序。</p>\\n<p>乱序产生的原因有好几种：</p>\\n<ul>\\n<li>编译器优化，在编译阶段将源码交换。</li>\\n<li>程序执行期间，指令流水被CPU乱序执行。</li>\\n<li>inherent cache 的分层及刷新策略使得有时候某些写读操作的从效果上看，顺序被重排。</li>\\n</ul>\\n<h2>Release和Acquire语义</h2>","autoDesc":true}');export{h as comp,d as data};
